package server

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	"github.com/jrsteele09/go-auth-server/clients"
	"github.com/jrsteele09/go-auth-server/tenants"
	"github.com/jrsteele09/go-auth-server/users"
)

const (
	// System tenant and client configuration
	SystemTenantName          = "system"
	SystemClientID            = "admin-dashboard"
	SystemClientName          = "Admin Dashboard"
	DefaultSuperAdminEmail    = "admin@system.local"
	DefaultSuperAdminUsername = "admin"
)

// BootstrapSystem creates the system tenant, admin client, and super admin user if they don't exist.
// This implements proper OAuth2 PKCE flow for all authentication, including admin access.
// Returns the generated password on first creation (empty string if already exists)
func (s *Server) BootstrapSystem(ctx context.Context) (generatedPassword string, err error) {
	log.Printf("üîß Bootstrap: Checking system configuration...")

	// Step 1: Create or get system tenant
	systemTenant, err := s.bootstrapSystemTenant(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to bootstrap system tenant: %w", err)
	}

	// Step 2: Create or get admin dashboard client (public client with PKCE)
	adminClient, err := s.bootstrapAdminClient(ctx, systemTenant.ID)
	if err != nil {
		return "", fmt.Errorf("failed to bootstrap admin client: %w", err)
	}

	// Step 3: Create or get super admin user
	generatedPassword, err = s.bootstrapSuperAdmin(ctx, systemTenant.ID)
	if err != nil {
		return "", fmt.Errorf("failed to bootstrap super admin: %w", err)
	}

	if generatedPassword != "" {
		log.Printf("‚úÖ Bootstrap complete: System initialized")
		log.Printf("   Tenant ID:   %s", systemTenant.ID)
		log.Printf("   Client ID:   %s", adminClient.ID)
		log.Printf("   Admin Email: %s", DefaultSuperAdminEmail)
		log.Printf("   Password:    %s", generatedPassword)
		log.Printf("   ‚ö†Ô∏è  SAVE THIS PASSWORD - it will not be displayed again!")
		log.Printf("   You will be required to change this password on first login.")
		log.Printf("")
		log.Printf("üîê Admin Dashboard OAuth2 Configuration:")
		log.Printf("   Authorization URL: http://localhost:8080/oauth2/authorize")
		log.Printf("   Token URL:         http://localhost:8080/oauth2/token")
		log.Printf("   Client ID:         %s", adminClient.ID)
		log.Printf("   Flow:              PKCE (no client secret required)")
		log.Printf("   Redirect URI:      http://localhost:8080/admin/callback")
	} else {
		log.Printf("‚úÖ Bootstrap: System already configured")
	}

	return generatedPassword, nil
}

// bootstrapSystemTenant creates the system tenant if it doesn't exist
func (s *Server) bootstrapSystemTenant(ctx context.Context) (*tenants.Tenant, error) {
	// Generate deterministic tenant ID: system-{first 8 chars of UUID}
	tenantUUID := uuid.New().String()[:8]
	tenantID := fmt.Sprintf("%s-%s", SystemTenantName, tenantUUID)

	// Check if a system tenant already exists
	allTenants, err := s.repos.Tenants.List(0, 100)
	if err != nil {
		return nil, fmt.Errorf("failed to list tenants: %w", err)
	}

	for _, t := range allTenants {
		if t.Name == SystemTenantName {
			log.Printf("   System tenant already exists: %s", t.ID)
			return t, nil
		}
	}

	// Create new system tenant
	systemTenant := &tenants.Tenant{
		ID:     tenantID,
		Name:   SystemTenantName,
		Domain: "system.local",
		Config: tenants.TenantConfig{
			Issuer:             fmt.Sprintf("http://localhost:8080"),
			Audience:           "system",
			AccessTokenExpiry:  15 * time.Minute,
			IDTokenExpiry:      1 * time.Hour,
			RefreshTokenExpiry: 7 * 24 * time.Hour,
		},
		// Keys will be generated by repo if needed
	}

	if err := s.repos.Tenants.Upsert(systemTenant); err != nil {
		return nil, fmt.Errorf("failed to create system tenant: %w", err)
	}

	log.Printf("   ‚úÖ Created system tenant: %s", tenantID)
	return systemTenant, nil
}

// bootstrapAdminClient creates a public OAuth2 client for the admin dashboard
func (s *Server) bootstrapAdminClient(ctx context.Context, tenantID string) (*clients.Client, error) {
	// Check if admin client already exists
	existingClient, err := s.repos.Clients.Get(SystemClientID)
	if err == nil && existingClient != nil {
		log.Printf("   Admin client already exists: %s", SystemClientID)
		return existingClient, nil
	}

	// Create public client (PKCE flow, no client secret)
	adminClient := &clients.Client{
		ID:          SystemClientID,
		Secret:      "", // Public client has no secret
		Description: SystemClientName,
		TenantID:    tenantID,
		Type:        clients.ClientTypePublic,
		RedirectURIs: []string{
			"http://localhost:8080/admin/callback",
			"http://localhost:3000/admin/callback", // Dev frontend
		},
		Scopes: []string{
			"openid",
			"profile",
			"email",
			"admin",         // Admin access scope
			"system:admin",  // System-level admin
			"tenant:manage", // Manage tenants
			"user:manage",   // Manage users
			"client:manage", // Manage OAuth clients
		},
	}

	if err := s.repos.Clients.Upsert(adminClient); err != nil {
		return nil, fmt.Errorf("failed to create admin client: %w", err)
	}

	log.Printf("   ‚úÖ Created admin client: %s (public, PKCE)", SystemClientID)
	return adminClient, nil
}

// bootstrapSuperAdmin creates the super admin user if none exists
func (s *Server) bootstrapSuperAdmin(ctx context.Context, tenantID string) (generatedPassword string, err error) {
	// Check if any super admin exists
	existingUsers, err := s.repos.Users.List("", 0, 10)
	if err != nil {
		return "", fmt.Errorf("failed to check for existing users: %w", err)
	}

	for _, user := range existingUsers {
		if user.IsSuperAdmin() {
			log.Printf("   Super admin already exists: %s", user.Email)
			return "", nil
		}
	}

	// Generate a secure random password
	passwordBytes := make([]byte, 16)
	if _, err := rand.Read(passwordBytes); err != nil {
		return "", fmt.Errorf("failed to generate password: %w", err)
	}
	generatedPassword = base64.URLEncoding.EncodeToString(passwordBytes)

	// Hash the password
	passwordHash, err := users.HashPassword(generatedPassword)
	if err != nil {
		return "", fmt.Errorf("failed to hash password: %w", err)
	}

	// Create the super admin user in the system tenant
	admin := &users.User{
		Email:        DefaultSuperAdminEmail,
		Username:     DefaultSuperAdminUsername,
		PasswordHash: passwordHash,
		FirstName:    "System",
		LastName:     "Administrator",
		SystemRoles:  []users.RoleType{users.RoleSuperAdmin},
		Tenants: []users.TenantMembership{
			{
				TenantID: tenantID,
				Roles:    []users.RoleType{users.RoleTenantAdmin},
				JoinedAt: time.Now(),
			},
		},
		Verified:               true,
		Blocked:                false,
		PasswordChangeRequired: true,
		MFType:                 users.MFNone,
	}

	// Sync tenant IDs
	admin.SyncTenantIDs()

	if err := s.repos.Users.Upsert(admin); err != nil {
		return "", fmt.Errorf("failed to create super admin: %w", err)
	}

	log.Printf("   ‚úÖ Created super admin: %s", admin.Email)
	return generatedPassword, nil
}
